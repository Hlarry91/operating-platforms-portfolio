# operating-platforms-portfolio
Final design document covering platform evaluation, server/client architecture, storage &amp; memory management, distributed systems, and security recommendations.
For The Gaming Roomâ€™s Draw It or Lose It, I designed a web-based, multiplatform solution that extends the Android application to a centralized service with a modern browser client. The client required strict enforcement of unique names for games, teams, and players, and also required that only one active game instance exist at any given time. I addressed these requirements with a concise Java service layer, a Singleton pattern for game lifecycle control, and explicit identity and uniqueness validation, all supported by a portable Linux deployment, RESTful APIs with optional WebSocket updates, and the use of object storage with a content delivery network for efficient image delivery. The strongest aspect of the work was the translation of requirements into specific architectural decisions so that the document functions as an implementation plan. Examples include stateless services for elastic scale, managed data services for reliability, and a continuous integration and delivery pipeline that supports horizontal growth. Producing the design before writing code was particularly helpful because it established clear boundaries, reduced rework, and clarified the testing strategy. If I were to revise any part, I would expand the operational playbook with service level objectives, alert thresholds, incident response procedures, and a basic cost model for storage, content delivery, and database tiers. User needs such as fast loading, responsive turns, and unambiguous identities guided choices like content delivery for images, real time updates through WebSockets, and strict uniqueness constraints. Centering these needs is essential in a time-constrained, collaborative game where delays or confusion quickly degrade the experience. My overall approach followed a consistent sequence of requirements, constraints, architecture, and then technology selection, with a preference for stateless patterns, horizontal scalability, and managed services. I plan to reuse this sequence and to continue documenting observability, deployment, and recovery alongside class design and API design so that the transition from design document to working code remains clear and efficient.
